/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. .\ognl.jj */
/*@egen*///--------------------------------------------------------------------------
//	Copyright (c) 1998-2004, Drew Davidson and Luke Blanshard
//  All rights reserved.
//
//	Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are
//  met:
//
//	Redistributions of source code must retain the above copyright notice,
//  this list of conditions and the following disclaimer.
//	Redistributions in binary form must reproduce the above copyright
//  notice, this list of conditions and the following disclaimer in the
//  documentation and/or other materials provided with the distribution.
//	Neither the name of the Drew Davidson nor the names of its contributors
//  may be used to endorse or promote products derived from this software
//  without specific prior written permission.
//
//	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
//  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
//  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
//  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
//  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
//  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
//  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
//  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
//  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
//  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
//  DAMAGE.
//--------------------------------------------------------------------------

/*
 * This file defines the syntax of OGNL, the Object-Graph Navigation Language.  This
 * language was devised by Drew Davidson, who called it Key-Value Coding Language.  Luke
 * Blanshard then made up the new name and reimplemented it using ANTLR, refining and
 * polishing the language a bit on the way.  Drew maintained the system for a couple of
 * years; then Luke converted the ANTLR grammar to JavaCC, to eliminate the run-time
 * dependency on ANTLR.
 *
 * See package.html for a description of the language.
 */

options {
      // Parser options
    LOOKAHEAD           = 1;
    STATIC              = false;
    JAVA_UNICODE_ESCAPE = true;
    UNICODE_INPUT       = true;                                                                                                                                                                                                           
}

PARSER_BEGIN(ICSExpParser)

package com.hisun.hiexpression.imp;

import java.math.*;
import org.apache.commons.lang.StringUtils;

/**
 * OgnlParser is a JavaCC parser class; it translates OGNL expressions into abstract
 * syntax trees (ASTs) that can then be interpreted by the getValue and setValue methods.
 */
public class ICSExpParser/*@bgen(jjtree)*/implements ICSExpParserTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected JJTICSExpParserState jjtree = new JJTICSExpParserState();

/*@egen*/
}

PARSER_END(ICSExpParser)




/**
 * This is the top-level construct of OGNL.
 */
Node topLevelExpression() : {}
{
	equalityExpression() <EOF> { return jjtree.rootNode(); }
}

// assignment expression (level n)
void equalityExpression() : {}
{
    relationalExpression() 
    (
    	( "==" )/*@bgen(jjtree) #Eq( 2) */
                  {
                    ASTEq jjtn001 = new ASTEq(JJTEQ);
                    boolean jjtc001 = true;
                    jjtree.openNodeScope(jjtn001);
                  }
                  try {
/*@egen*/  relationalExpression()/*@bgen(jjtree)*/
                  } catch (Throwable jjte001) {
                    if (jjtc001) {
                      jjtree.clearNodeScope(jjtn001);
                      jjtc001 = false;
                    } else {
                      jjtree.popNode();
                    }
                    if (jjte001 instanceof RuntimeException) {
                      throw (RuntimeException)jjte001;
                    }
                    if (jjte001 instanceof ParseException) {
                      throw (ParseException)jjte001;
                    }
                    throw (Error)jjte001;
                  } finally {
                    if (jjtc001) {
                      jjtree.closeNodeScope(jjtn001,  2);
                    }
                  }
/*@egen*/ 
	|
		( "!=" )/*@bgen(jjtree) #NotEq( 2) */
                         {
                           ASTNotEq jjtn002 = new ASTNotEq(JJTNOTEQ);
                           boolean jjtc002 = true;
                           jjtree.openNodeScope(jjtn002);
                         }
                         try {
/*@egen*/ relationalExpression()/*@bgen(jjtree)*/
                         } catch (Throwable jjte002) {
                           if (jjtc002) {
                             jjtree.clearNodeScope(jjtn002);
                             jjtc002 = false;
                           } else {
                             jjtree.popNode();
                           }
                           if (jjte002 instanceof RuntimeException) {
                             throw (RuntimeException)jjte002;
                           }
                           if (jjte002 instanceof ParseException) {
                             throw (ParseException)jjte002;
                           }
                           throw (Error)jjte002;
                         } finally {
                           if (jjtc002) {
                             jjtree.closeNodeScope(jjtn002,  2);
                           }
                         }
/*@egen*/ 
    )*
}

// boolean relational expressions (level 5)
void relationalExpression() : {}
{
    primaryExpression()
    (
        ("<" )/*@bgen(jjtree) #Less( 2) */
               {
                 ASTLess jjtn001 = new ASTLess(JJTLESS);
                 boolean jjtc001 = true;
                 jjtree.openNodeScope(jjtn001);
               }
               try {
/*@egen*/ primaryExpression()/*@bgen(jjtree)*/
               } catch (Throwable jjte001) {
                 if (jjtc001) {
                   jjtree.clearNodeScope(jjtn001);
                   jjtc001 = false;
                 } else {
                   jjtree.popNode();
                 }
                 if (jjte001 instanceof RuntimeException) {
                   throw (RuntimeException)jjte001;
                 }
                 if (jjte001 instanceof ParseException) {
                   throw (ParseException)jjte001;
                 }
                 throw (Error)jjte001;
               } finally {
                 if (jjtc001) {
                   jjtree.closeNodeScope(jjtn001,  2);
                 }
               }
/*@egen*/
     |
        (">" )/*@bgen(jjtree) #Greater( 2) */
               {
                 ASTGreater jjtn002 = new ASTGreater(JJTGREATER);
                 boolean jjtc002 = true;
                 jjtree.openNodeScope(jjtn002);
               }
               try {
/*@egen*/ primaryExpression()/*@bgen(jjtree)*/
               } catch (Throwable jjte002) {
                 if (jjtc002) {
                   jjtree.clearNodeScope(jjtn002);
                   jjtc002 = false;
                 } else {
                   jjtree.popNode();
                 }
                 if (jjte002 instanceof RuntimeException) {
                   throw (RuntimeException)jjte002;
                 }
                 if (jjte002 instanceof ParseException) {
                   throw (ParseException)jjte002;
                 }
                 throw (Error)jjte002;
               } finally {
                 if (jjtc002) {
                   jjtree.closeNodeScope(jjtn002,  2);
                 }
               }
/*@egen*/
     |
        ("<=" )/*@bgen(jjtree) #LessEq( 2) */
                {
                  ASTLessEq jjtn003 = new ASTLessEq(JJTLESSEQ);
                  boolean jjtc003 = true;
                  jjtree.openNodeScope(jjtn003);
                }
                try {
/*@egen*/ primaryExpression()/*@bgen(jjtree)*/
                } catch (Throwable jjte003) {
                  if (jjtc003) {
                    jjtree.clearNodeScope(jjtn003);
                    jjtc003 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte003 instanceof RuntimeException) {
                    throw (RuntimeException)jjte003;
                  }
                  if (jjte003 instanceof ParseException) {
                    throw (ParseException)jjte003;
                  }
                  throw (Error)jjte003;
                } finally {
                  if (jjtc003) {
                    jjtree.closeNodeScope(jjtn003,  2);
                  }
                }
/*@egen*/
     |
        (">=" )/*@bgen(jjtree) #GreaterEq( 2) */
                {
                  ASTGreaterEq jjtn004 = new ASTGreaterEq(JJTGREATEREQ);
                  boolean jjtc004 = true;
                  jjtree.openNodeScope(jjtn004);
                }
                try {
/*@egen*/ primaryExpression()/*@bgen(jjtree)*/
                } catch (Throwable jjte004) {
                  if (jjtc004) {
                    jjtree.clearNodeScope(jjtn004);
                    jjtc004 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte004 instanceof RuntimeException) {
                    throw (RuntimeException)jjte004;
                  }
                  if (jjte004 instanceof ParseException) {
                    throw (ParseException)jjte004;
                  }
                  throw (Error)jjte004;
                } finally {
                  if (jjtc004) {
                    jjtree.closeNodeScope(jjtn004,  2);
                  }
                }
/*@egen*/
    )*
}

//ics\u8868\u8fbe\u5f0f\u6570\u636e\u6e90\u8282\u70b9(@BAS\u7b49)
void icsValueRef() : {
    Token   t;
}
{
	(
	    "@BAS." t=<IDENT>/*@bgen(jjtree) #IcsVarRef( 0) */
                              {
                                ASTIcsVarRef jjtn001 = new ASTIcsVarRef(JJTICSVARREF);
                                boolean jjtc001 = true;
                                jjtree.openNodeScope(jjtn001);
                              }
                              try {
/*@egen*//*@bgen(jjtree)*/
                              {
                                jjtree.closeNodeScope(jjtn001,  0);
                                jjtc001 = false;
                              }
/*@egen*/ { jjtn001.setItemName(0, t.image ); }/*@bgen(jjtree)*/
                              } finally {
                                if (jjtc001) {
                                  jjtree.closeNodeScope(jjtn001,  0);
                                }
                              }
/*@egen*/
	 |	"@BCFG." t=<IDENT>/*@bgen(jjtree) #IcsVarRef( 0) */
                                   {
                                     ASTIcsVarRef jjtn002 = new ASTIcsVarRef(JJTICSVARREF);
                                     boolean jjtc002 = true;
                                     jjtree.openNodeScope(jjtn002);
                                   }
                                   try {
/*@egen*//*@bgen(jjtree)*/
                                   {
                                     jjtree.closeNodeScope(jjtn002,  0);
                                     jjtc002 = false;
                                   }
/*@egen*/ { jjtn002.setItemName(1, t.image ); }/*@bgen(jjtree)*/
                                   } finally {
                                     if (jjtc002) {
                                       jjtree.closeNodeScope(jjtn002,  0);
                                     }
                                   }
/*@egen*/
	 |	"@MSG." t=<IDENT>/*@bgen(jjtree) #IcsVarRef( 0) */
                                  {
                                    ASTIcsVarRef jjtn003 = new ASTIcsVarRef(JJTICSVARREF);
                                    boolean jjtc003 = true;
                                    jjtree.openNodeScope(jjtn003);
                                  }
                                  try {
/*@egen*//*@bgen(jjtree)*/
                                  {
                                    jjtree.closeNodeScope(jjtn003,  0);
                                    jjtc003 = false;
                                  }
/*@egen*/ { jjtn003.setItemName(2, t.image ); }/*@bgen(jjtree)*/
                                  } finally {
                                    if (jjtc003) {
                                      jjtree.closeNodeScope(jjtn003,  0);
                                    }
                                  }
/*@egen*/
	 |	"@ETF." t=<IDENT>/*@bgen(jjtree) #IcsVarRef( 0) */
                                  {
                                    ASTIcsVarRef jjtn004 = new ASTIcsVarRef(JJTICSVARREF);
                                    boolean jjtc004 = true;
                                    jjtree.openNodeScope(jjtn004);
                                  }
                                  try {
/*@egen*//*@bgen(jjtree)*/
                                  {
                                    jjtree.closeNodeScope(jjtn004,  0);
                                    jjtc004 = false;
                                  }
/*@egen*/ { jjtn004.setItemName(3, t.image ); }/*@bgen(jjtree)*/
                                  } finally {
                                    if (jjtc004) {
                                      jjtree.closeNodeScope(jjtn004,  0);
                                    }
                                  }
/*@egen*/
	 |	"@PARA." t=<IDENT>/*@bgen(jjtree) #IcsVarRef( 0) */
                                   {
                                     ASTIcsVarRef jjtn005 = new ASTIcsVarRef(JJTICSVARREF);
                                     boolean jjtc005 = true;
                                     jjtree.openNodeScope(jjtn005);
                                   }
                                   try {
/*@egen*//*@bgen(jjtree)*/
                                   {
                                     jjtree.closeNodeScope(jjtn005,  0);
                                     jjtc005 = false;
                                   }
/*@egen*/ { jjtn005.setItemName(4, t.image ); }/*@bgen(jjtree)*/
                                   } finally {
                                     if (jjtc005) {
                                       jjtree.closeNodeScope(jjtn005,  0);
                                     }
                                   }
/*@egen*/
	 |	"@SYS." t=<IDENT>/*@bgen(jjtree) #IcsVarRef( 0) */
                                  {
                                    ASTIcsVarRef jjtn006 = new ASTIcsVarRef(JJTICSVARREF);
                                    boolean jjtc006 = true;
                                    jjtree.openNodeScope(jjtn006);
                                  }
                                  try {
/*@egen*//*@bgen(jjtree)*/
                                  {
                                    jjtree.closeNodeScope(jjtn006,  0);
                                    jjtc006 = false;
                                  }
/*@egen*/ { jjtn006.setItemName(6, t.image ); }/*@bgen(jjtree)*/
                                  } finally {
                                    if (jjtc006) {
                                      jjtree.closeNodeScope(jjtn006,  0);
                                    }
                                  }
/*@egen*/
	 |	"$" t=<IDENT>/*@bgen(jjtree) #IcsVarRef( 0) */
                              {
                                ASTIcsVarRef jjtn007 = new ASTIcsVarRef(JJTICSVARREF);
                                boolean jjtc007 = true;
                                jjtree.openNodeScope(jjtn007);
                              }
                              try {
/*@egen*//*@bgen(jjtree)*/
                              {
                                jjtree.closeNodeScope(jjtn007,  0);
                                jjtc007 = false;
                              }
/*@egen*/ { jjtn007.setItemName(3, t.image ); }/*@bgen(jjtree)*/
                              } finally {
                                if (jjtc007) {
                                  jjtree.closeNodeScope(jjtn007,  0);
                                }
                              }
/*@egen*/
	 |	"~" t=<IDENT>/*@bgen(jjtree) #IcsVarRef( 0) */
                              {
                                ASTIcsVarRef jjtn008 = new ASTIcsVarRef(JJTICSVARREF);
                                boolean jjtc008 = true;
                                jjtree.openNodeScope(jjtn008);
                              }
                              try {
/*@egen*//*@bgen(jjtree)*/
                              {
                                jjtree.closeNodeScope(jjtn008,  0);
                                jjtc008 = false;
                              }
/*@egen*/ { jjtn008.setItemName(0, t.image ); }/*@bgen(jjtree)*/
                              } finally {
                                if (jjtc008) {
                                  jjtree.closeNodeScope(jjtn008,  0);
                                }
                              }
/*@egen*/
	 |	"%" t=<IDENT>/*@bgen(jjtree) #IcsVarRef( 0) */
                              {
                                ASTIcsVarRef jjtn009 = new ASTIcsVarRef(JJTICSVARREF);
                                boolean jjtc009 = true;
                                jjtree.openNodeScope(jjtn009);
                              }
                              try {
/*@egen*//*@bgen(jjtree)*/
                              {
                                jjtree.closeNodeScope(jjtn009,  0);
                                jjtc009 = false;
                              }
/*@egen*/ { jjtn009.setItemName(2, t.image ); }/*@bgen(jjtree)*/
                              } finally {
                                if (jjtc009) {
                                  jjtree.closeNodeScope(jjtn009,  0);
                                }
                              }
/*@egen*/
	 |	"#" t=<IDENT>/*@bgen(jjtree) #IcsVarRef( 0) */
                              {
                                ASTIcsVarRef jjtn010 = new ASTIcsVarRef(JJTICSVARREF);
                                boolean jjtc010 = true;
                                jjtree.openNodeScope(jjtn010);
                              }
                              try {
/*@egen*//*@bgen(jjtree)*/
                              {
                                jjtree.closeNodeScope(jjtn010,  0);
                                jjtc010 = false;
                              }
/*@egen*/ { jjtn010.setItemName(4, t.image ); }/*@bgen(jjtree)*/
                              } finally {
                                if (jjtc010) {
                                  jjtree.closeNodeScope(jjtn010,  0);
                                }
                              }
/*@egen*/
	 |	"@" t=<IDENT>/*@bgen(jjtree) #IcsVarRef( 0) */
                              {
                                ASTIcsVarRef jjtn011 = new ASTIcsVarRef(JJTICSVARREF);
                                boolean jjtc011 = true;
                                jjtree.openNodeScope(jjtn011);
                              }
                              try {
/*@egen*//*@bgen(jjtree)*/
                              {
                                jjtree.closeNodeScope(jjtn011,  0);
                                jjtc011 = false;
                              }
/*@egen*/ { jjtn011.setItemName(5, t.image ); }/*@bgen(jjtree)*/
                              } finally {
                                if (jjtc011) {
                                  jjtree.closeNodeScope(jjtn011,  0);
                                }
                              }
/*@egen*/
	)
}


void primaryExpression() : {
    Token   t;
    String  className = null;
}
{
    (
        "true"/*@bgen(jjtree) #Const( 0) */
                                                {
                                                  ASTConst jjtn001 = new ASTConst(JJTCONST);
                                                  boolean jjtc001 = true;
                                                  jjtree.openNodeScope(jjtn001);
                                                }
                                                try {
/*@egen*//*@bgen(jjtree)*/
                                                {
                                                  jjtree.closeNodeScope(jjtn001,  0);
                                                  jjtc001 = false;
                                                }
/*@egen*/                                  { jjtn001.setValue( Boolean.TRUE ); }/*@bgen(jjtree)*/
                                                } finally {
                                                  if (jjtc001) {
                                                    jjtree.closeNodeScope(jjtn001,  0);
                                                  }
                                                }
/*@egen*/
     |
        "false"/*@bgen(jjtree) #Const( 0) */
                                                {
                                                  ASTConst jjtn002 = new ASTConst(JJTCONST);
                                                  boolean jjtc002 = true;
                                                  jjtree.openNodeScope(jjtn002);
                                                }
                                                try {
/*@egen*//*@bgen(jjtree)*/
                                                {
                                                  jjtree.closeNodeScope(jjtn002,  0);
                                                  jjtc002 = false;
                                                }
/*@egen*/                                 { jjtn002.setValue( Boolean.FALSE ); }/*@bgen(jjtree)*/
                                                } finally {
                                                  if (jjtc002) {
                                                    jjtree.closeNodeScope(jjtn002,  0);
                                                  }
                                                }
/*@egen*/
     |/*@bgen(jjtree) #Const( 0) */
        {
          ASTConst jjtn003 = new ASTConst(JJTCONST);
          boolean jjtc003 = true;
          jjtree.openNodeScope(jjtn003);
        }
        try {
/*@egen*/
        "null"/*@bgen(jjtree)*/
        } finally {
          if (jjtc003) {
            jjtree.closeNodeScope(jjtn003,  0);
          }
        }
/*@egen*/                        // Null is the default value in an ASTConst
     |
        LOOKAHEAD(2) staticMethodCall()
     |
        (<CHAR_LITERAL> | <BACK_CHAR_LITERAL> | <STRING_LITERAL>)/*@bgen(jjtree) #Const( 0) */
                                                {
                                                  ASTConst jjtn004 = new ASTConst(JJTCONST);
                                                  boolean jjtc004 = true;
                                                  jjtree.openNodeScope(jjtn004);
                                                }
                                                try {
/*@egen*//*@bgen(jjtree)*/
                                                {
                                                  jjtree.closeNodeScope(jjtn004,  0);
                                                  jjtc004 = false;
                                                }
/*@egen*/
                                                { jjtn004.setValue( token_source.literalValue ); }/*@bgen(jjtree)*/
                                                } finally {
                                                  if (jjtc004) {
                                                    jjtree.closeNodeScope(jjtn004,  0);
                                                  }
                                                }
/*@egen*/
     |
        icsValueRef()
     |
        "(" equalityExpression() ")"
    )
}

void staticMethodCall()               : {/*@bgen(jjtree) StaticMethod */
    ASTStaticMethod jjtn000 = new ASTStaticMethod(JJTSTATICMETHOD);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
    String className = "com.hisun.hiexpression.HiExpBasicFunctions";
}
{/*@bgen(jjtree) StaticMethod */
    try {
/*@egen*/
    t=<IDENT> "(" [ primaryExpression() ( "," primaryExpression() )* ] ")"/*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn000, true);
                                          jjtc000 = false;
                                        }
/*@egen*/
                                        { jjtn000.init( className, t.image ); }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

// LEXER PRODUCTIONS

TOKEN_MGR_DECLS:
{
      /** Holds the last value computed by a constant token. */
    Object literalValue;
      /** Holds the last character escaped or in a character literal. */
    private char charValue;
      /** Holds char literal start token. */
    private char charLiteralStartQuote;
      /** Holds the last string literal parsed. */
    private StringBuffer stringBuffer;

      /** Converts an escape sequence into a character value. */
    private char escapeChar()
    {
        int ofs = image.length() - 1;
        switch ( image.charAt(ofs) ) {
            case 'n':   return '\n';
            case 'r':   return '\r';
            case 't':   return '\t';
            case 'b':   return '\b';
            case 'f':   return '\f';
            case '\\':  return '\\';
            case '\'':  return '\'';
            case '\"':  return '\"';
        }

          // Otherwise, it's an octal number.  Find the backslash and convert.
        while ( image.charAt(--ofs) != '\\' )
          {}
        int value = 0;
        while ( ++ofs < image.length() )
            value = (value << 3) | (image.charAt(ofs) - '0');
        return (char) value;
    }

    private Object makeInt()
    {
        Object  result;
        String  s = image.toString();
        int     base = 10;

        if ( s.charAt(0) == '0' )
            base = (s.length() > 1 && (s.charAt(1) == 'x' || s.charAt(1) == 'X'))? 16 : 8;
        if ( base == 16 )
            s = s.substring(2); // Trim the 0x off the front
        switch ( s.charAt(s.length()-1) ) {
            case 'l': case 'L':
                result = Long.valueOf( s.substring(0,s.length()-1), base );
                break;

            case 'h': case 'H':
                result = new BigInteger( s.substring(0,s.length()-1), base );
                break;

            default:
                result = Integer.valueOf( s, base );
                break;
        }
        return result;
    }

    private Object makeFloat()
    {
        String s = image.toString();
        switch ( s.charAt(s.length()-1) ) {
            case 'f': case 'F':
                return Float.valueOf( s );

            case 'b': case 'B':
                return new BigDecimal( s.substring(0,s.length()-1) );

            case 'd': case 'D':
            default:
                return Double.valueOf( s );
        }
    }
}

// Whitespace -- ignored
SKIP:
{  " " | "\t" | "\f" | "\r" | "\n" }

// An identifier.
TOKEN:
{
    < IDENT: <LETTER> (<LETTER>|<DIGIT>)* ("." <LETTER> (<LETTER>|<DIGIT>)*)*>
 |
    < #LETTER: [
//       "$",
       "A"-"Z",
       "_",
       "a"-"z",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ] >
 |
    < #DIGIT:
      [
       "0"-"9",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ] >
}

/**
 * Character and string literals, whose object value is stored in the token manager's
 * "literalValue" field.
 */
MORE:
{
    "`"     : WithinBackCharLiteral
 |
    "'"     { stringBuffer = new StringBuffer(); }: WithinCharLiteral
 |
    "\""    { stringBuffer = new StringBuffer(); }: WithinStringLiteral
}

<WithinCharLiteral> MORE:
{
    < ESC: "\\" ( ["n","r","t","b","f","\\","'","`","\""]
                | (["0"-"3"])? ["0"-"7"] (["0"-"7"])?
                )
    >
        { charValue = escapeChar(); stringBuffer.append(charValue); }
 |
    < (~["'","\\"]) >
        { charValue = image.charAt( image.length()-1 ); stringBuffer.append(charValue); }
}

<WithinCharLiteral> TOKEN:
{
    < CHAR_LITERAL: "'">
        {
            if (stringBuffer.length() == 1) {
//                literalValue = new Character( charValue );
                literalValue = new String( "" + charValue );
            } else {
                literalValue = new String( stringBuffer );
            }
        }
        : DEFAULT
}

<WithinBackCharLiteral> MORE:
{
    < BACK_CHAR_ESC: <ESC> >
        { charValue = escapeChar(); }
 |
    < (~["`","\\"]) >
        { charValue = image.charAt( image.length()-1 ); }
}

<WithinBackCharLiteral> TOKEN:
{
    < BACK_CHAR_LITERAL: "`">
        { literalValue = new Character( charValue ); }: DEFAULT
}

<WithinStringLiteral> MORE:
{
    < STRING_ESC: <ESC> >
        { stringBuffer.append( escapeChar() ); }
 |
    < (~["\"","\\"]) >
        { stringBuffer.append( image.charAt(image.length()-1) ); }
}

<WithinStringLiteral> TOKEN:
{
    <STRING_LITERAL: "\"">
        { literalValue = new String( stringBuffer ); }
        : DEFAULT
}

/**
 * Integer or real Numeric literal, whose object value is stored in the token manager's
 * "literalValue" field.
 */
TOKEN:
{
    < INT_LITERAL:
        ( "0" (["0"-"7"])* | ["1"-"9"] (["0"-"9"])* | "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ )
        (["l","L","h","H"])?
    >
        { literalValue =
        makeInt(); }
 |
    < FLT_LITERAL:
        ( <DEC_FLT> (<EXPONENT>)? (<FLT_SUFF>)?
        | <DEC_DIGITS> <EXPONENT> (<FLT_SUFF>)?
        | <DEC_DIGITS> <FLT_SUFF>
        )
    >
        { literalValue = makeFloat(); }

 |  < #DEC_FLT: (["0"-"9"])+ "." (["0"-"9"])* | "." (["0"-"9"])+ >
 |  < #DEC_DIGITS: (["0"-"9"])+ >
 |  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
 |  < #FLT_SUFF: ["d","D","f","F","b","B"] >
}


//--------------------------------------------------------------------------
//	Copyright (c) 1998-2004, Drew Davidson and Luke Blanshard
//  All rights reserved.
//
//	Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are
//  met:
//
//	Redistributions of source code must retain the above copyright notice,
//  this list of conditions and the following disclaimer.
//	Redistributions in binary form must reproduce the above copyright
//  notice, this list of conditions and the following disclaimer in the
//  documentation and/or other materials provided with the distribution.
//	Neither the name of the Drew Davidson nor the names of its contributors
//  may be used to endorse or promote products derived from this software
//  without specific prior written permission.
//
//	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
//  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
//  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
//  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
//  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
//  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
//  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
//  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
//  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
//  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
//  DAMAGE.
//--------------------------------------------------------------------------

/*
 * This file defines the syntax of OGNL, the Object-Graph Navigation Language.  This
 * language was devised by Drew Davidson, who called it Key-Value Coding Language.  Luke
 * Blanshard then made up the new name and reimplemented it using ANTLR, refining and
 * polishing the language a bit on the way.  Drew maintained the system for a couple of
 * years; then Luke converted the ANTLR grammar to JavaCC, to eliminate the run-time
 * dependency on ANTLR.
 *
 * See package.html for a description of the language.
 */

options {
      // Parser options
    LOOKAHEAD           = 1;
    STATIC              = false;
    JAVA_UNICODE_ESCAPE = true;
    UNICODE_INPUT       = true;
//	DEBUG_PARSER		= true;
//	CHOICE_AMBIGUITY_CHECK = 3;
//	DEBUG_TOKEN_MANAGER	= true;
	
      // Tree options
    MULTI             = true;
    NODE_DEFAULT_VOID = true;
    VISITOR 		  = true;
}

PARSER_BEGIN(ICSExpParser)

package com.hisun.hiexpression.imp;

import java.math.*;
import org.apache.commons.lang.StringUtils;

/**
 * OgnlParser is a JavaCC parser class; it translates OGNL expressions into abstract
 * syntax trees (ASTs) that can then be interpreted by the getValue and setValue methods.
 */
public class ICSExpParser
{
}

PARSER_END(ICSExpParser)




/**
 * This is the top-level construct of OGNL.
 */
Node topLevelExpression() : {}
{
	equalityExpression() <EOF> { return jjtree.rootNode(); }
}

// assignment expression (level n)
void equalityExpression() : {}
{
    relationalExpression() 
    (
    	( "==" )  relationalExpression() #Eq(2) 
	|
		( "!=" ) relationalExpression() #NotEq(2) 
    )*
}

// boolean relational expressions (level 5)
void relationalExpression() : {}
{
    primaryExpression()
    (
        ("<" ) primaryExpression() #Less(2)
     |
        (">" ) primaryExpression() #Greater(2)
     |
        ("<=" ) primaryExpression() #LessEq(2)
     |
        (">=" ) primaryExpression() #GreaterEq(2)
    )*
}

//ics表达式数据源节点(@BAS等)
void icsValueRef() : {
    Token   t;
}
{
	(
	    "@BAS." t=<IDENT> { jjtThis.setItemName(0, t.image ); } #IcsVarRef(0)
	 |	"@BCFG." t=<IDENT> { jjtThis.setItemName(1, t.image ); } #IcsVarRef(0)
	 |	"@MSG." t=<IDENT> { jjtThis.setItemName(2, t.image ); } #IcsVarRef(0)
	 |	"@ETF." t=<IDENT> { jjtThis.setItemName(3, t.image ); } #IcsVarRef(0)
	 |	"@PARA." t=<IDENT> { jjtThis.setItemName(4, t.image ); } #IcsVarRef(0)
	 |	"@SYS." t=<IDENT> { jjtThis.setItemName(6, t.image ); } #IcsVarRef(0)
	 |	"$" t=<IDENT> { jjtThis.setItemName(3, t.image ); } #IcsVarRef(0)
	 |	"~" t=<IDENT> { jjtThis.setItemName(0, t.image ); } #IcsVarRef(0)
	 |	"%" t=<IDENT> { jjtThis.setItemName(2, t.image ); } #IcsVarRef(0)
	 |	"#" t=<IDENT> { jjtThis.setItemName(4, t.image ); } #IcsVarRef(0)
	 |	"@" t=<IDENT> { jjtThis.setItemName(5, t.image ); } #IcsVarRef(0)
	)
}


void primaryExpression() : {
    Token   t;
    String  className = null;
}
{
    (
        "true"                                  { jjtThis.setValue( Boolean.TRUE ); }  #Const(0)
     |
        "false"                                 { jjtThis.setValue( Boolean.FALSE ); } #Const(0)
     |
        "null" #Const(0)                        // Null is the default value in an ASTConst
     |
        LOOKAHEAD(2) staticMethodCall()
     |
        (<CHAR_LITERAL> | <BACK_CHAR_LITERAL> | <STRING_LITERAL>)
                                                { jjtThis.setValue( token_source.literalValue ); } #Const(0)
     |
        icsValueRef()
     |
        "(" equalityExpression() ")"
    )
}

void staticMethodCall() #StaticMethod : {
    Token t;
    String className = "com.hisun.hiexpression.HiExpBasicFunctions";
}
{
    t=<IDENT> "(" [ primaryExpression() ( "," primaryExpression() )* ] ")"
                                        { jjtThis.init( className, t.image ); }
}

// LEXER PRODUCTIONS

TOKEN_MGR_DECLS:
{
      /** Holds the last value computed by a constant token. */
    Object literalValue;
      /** Holds the last character escaped or in a character literal. */
    private char charValue;
      /** Holds char literal start token. */
    private char charLiteralStartQuote;
      /** Holds the last string literal parsed. */
    private StringBuffer stringBuffer;

      /** Converts an escape sequence into a character value. */
    private char escapeChar()
    {
        int ofs = image.length() - 1;
        switch ( image.charAt(ofs) ) {
            case 'n':   return '\n';
            case 'r':   return '\r';
            case 't':   return '\t';
            case 'b':   return '\b';
            case 'f':   return '\f';
            case '\\':  return '\\';
            case '\'':  return '\'';
            case '\"':  return '\"';
        }

          // Otherwise, it's an octal number.  Find the backslash and convert.
        while ( image.charAt(--ofs) != '\\' )
          {}
        int value = 0;
        while ( ++ofs < image.length() )
            value = (value << 3) | (image.charAt(ofs) - '0');
        return (char) value;
    }

    private Object makeInt()
    {
        Object  result;
        String  s = image.toString();
        int     base = 10;

        if ( s.charAt(0) == '0' )
            base = (s.length() > 1 && (s.charAt(1) == 'x' || s.charAt(1) == 'X'))? 16 : 8;
        if ( base == 16 )
            s = s.substring(2); // Trim the 0x off the front
        switch ( s.charAt(s.length()-1) ) {
            case 'l': case 'L':
                result = Long.valueOf( s.substring(0,s.length()-1), base );
                break;

            case 'h': case 'H':
                result = new BigInteger( s.substring(0,s.length()-1), base );
                break;

            default:
                result = Integer.valueOf( s, base );
                break;
        }
        return result;
    }

    private Object makeFloat()
    {
        String s = image.toString();
        switch ( s.charAt(s.length()-1) ) {
            case 'f': case 'F':
                return Float.valueOf( s );

            case 'b': case 'B':
                return new BigDecimal( s.substring(0,s.length()-1) );

            case 'd': case 'D':
            default:
                return Double.valueOf( s );
        }
    }
}

// Whitespace -- ignored
SKIP:
{  " " | "\t" | "\f" | "\r" | "\n" }

// An identifier.
TOKEN:
{
    < IDENT: <LETTER> (<LETTER>|<DIGIT>)* ("." <LETTER> (<LETTER>|<DIGIT>)*)*>
 |
    < #LETTER: [
//       "\u0024",
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ] >
 |
    < #DIGIT:
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ] >
}

/**
 * Character and string literals, whose object value is stored in the token manager's
 * "literalValue" field.
 */
MORE:
{
    "`"     : WithinBackCharLiteral
 |
    "'"     { stringBuffer = new StringBuffer(); }: WithinCharLiteral
 |
    "\""    { stringBuffer = new StringBuffer(); }: WithinStringLiteral
}

<WithinCharLiteral> MORE:
{
    < ESC: "\\" ( ["n","r","t","b","f","\\","'","`","\""]
                | (["0"-"3"])? ["0"-"7"] (["0"-"7"])?
                )
    >
        { charValue = escapeChar(); stringBuffer.append(charValue); }
 |
    < (~["'","\\"]) >
        { charValue = image.charAt( image.length()-1 ); stringBuffer.append(charValue); }
}

<WithinCharLiteral> TOKEN:
{
    < CHAR_LITERAL: "'">
        {
            if (stringBuffer.length() == 1) {
//                literalValue = new Character( charValue );
                literalValue = new String( "" + charValue );
            } else {
                literalValue = new String( stringBuffer );
            }
        }
        : DEFAULT
}

<WithinBackCharLiteral> MORE:
{
    < BACK_CHAR_ESC: <ESC> >
        { charValue = escapeChar(); }
 |
    < (~["`","\\"]) >
        { charValue = image.charAt( image.length()-1 ); }
}

<WithinBackCharLiteral> TOKEN:
{
    < BACK_CHAR_LITERAL: "`">
        { literalValue = new Character( charValue ); }: DEFAULT
}

<WithinStringLiteral> MORE:
{
    < STRING_ESC: <ESC> >
        { stringBuffer.append( escapeChar() ); }
 |
    < (~["\"","\\"]) >
        { stringBuffer.append( image.charAt(image.length()-1) ); }
}

<WithinStringLiteral> TOKEN:
{
    <STRING_LITERAL: "\"">
        { literalValue = new String( stringBuffer ); }
        : DEFAULT
}

/**
 * Integer or real Numeric literal, whose object value is stored in the token manager's
 * "literalValue" field.
 */
TOKEN:
{
    < INT_LITERAL:
        ( "0" (["0"-"7"])* | ["1"-"9"] (["0"-"9"])* | "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ )
        (["l","L","h","H"])?
    >
        { literalValue =
        makeInt(); }
 |
    < FLT_LITERAL:
        ( <DEC_FLT> (<EXPONENT>)? (<FLT_SUFF>)?
        | <DEC_DIGITS> <EXPONENT> (<FLT_SUFF>)?
        | <DEC_DIGITS> <FLT_SUFF>
        )
    >
        { literalValue = makeFloat(); }

 |  < #DEC_FLT: (["0"-"9"])+ "." (["0"-"9"])* | "." (["0"-"9"])+ >
 |  < #DEC_DIGITS: (["0"-"9"])+ >
 |  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
 |  < #FLT_SUFF: ["d","D","f","F","b","B"] >
}

